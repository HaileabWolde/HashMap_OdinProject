# HashMap are ways of storing data based on keys for a better search speed and saves us a ton of time and space 
# we can imagine HashMap like a librerist trying to give us the book we need if the books are organized in way that are easy to find later on it wouldn't take the librariean so much time to give us the book we need that is the same thing here to for Hashmaps.
# so it gives each index in the array a specfiec hashed code that is unqiue to that index to find it easier later on.
# so How does it work? we would have Bucket, which is value storer inside the index and we would have hash function that hash the key and would give us an index on which the key-value pair would be stored and when we start to search that key-value pair we would hash the key and know which index exactly contains the value. 
Here are some function created on the Hashmap object:
hash(key): creates hash function that hashes each key to a specfic index 
set(key, value): hash the key which gives us a specfice index then create a node that contains key, value, and next and then if their is no value inside the index at the array we should put this newly created node insied that index, but sometimes two or more values can be hashed to the same index in this case assign a variable to the head and then loop through the nodes until u find a node who doesnot have a next node pointed to and then set that node to the newly created Node.
get(key, value): so to find the index where this key-value are stored hash the key and find the index on the array where the value is stored and since many values can be stored on the index loop through the nodes until u find the value and return that value.
remove(key); creates two variable One Current and One Prev and the Current is pointing to the head and the prev is null and if the Current is null meaning there is nothing there and there is nothing to remove and if the current is the only value to be removed meaning there is no node inside the next then the value at that index will be null.and if not it should transverse through the nodes while the current is being assigned to the current next and prev being assigned to the current and when it found the key previous next properties should be pointing to the current next which makes the current being poped off.
so know let's talk about loadFactorTreshold, capcity and why they are important 
#capacity: is the amount of bucket insied of our array or how much it can hold,
#thresshold: is the maximum limit of buckets we should be using before we expand our buckets 
    but why do we need to expand our bucket,
if we keep hashing keys a large amount of keys there will high chances that a lot of keys will be hashed to one index which will cause cramming which slow storage, and also take time so that is why we need threeshold , capcity.
resize(): so for each set of key-value pairs we check for the length and count the amount of nodes we have and divied that by the capacity and if it is higher than the threeshold the we call the resize function in which it will double the capcity and will creaet a new bucket and hash the key-value pair in the newly created bucket.